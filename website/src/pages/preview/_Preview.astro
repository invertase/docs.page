---
import Root from '@layouts/Root.astro';
import DocsView from '@layouts/DocsView.astro';
import context from 'src/context';

const isPreviewReady = context.get().isPreviewReady;
---

<script>
  import { getPreview, type GetPreviewResponse } from 'src/bundle';
  import context, { type Context } from 'src/context';
  import { replaceMoustacheVariables } from 'src/utils';
  import { openDB, deleteDB, wrap, unwrap } from 'idb';

  context.subscribe((ctx: Context) => {
    console.log(ctx.isPreviewReady)
  });

  const DB_NAME = 'docspage-preview-store';
  const STORE_NAME = 'docspage-preview-files';
  const CONTEXT_KEY = 'context';
  const DB_VERSION = 1;

  const db = await openDB(DB_NAME, DB_VERSION, {
    upgrade(db) {
      db.createObjectStore(STORE_NAME);
    },
  });

  async function addFileToDb(file: FileEntry): Promise<void> {
    await db.put(STORE_NAME, file.name, file.content);
  }
  async function saveContextInIDB(ctx: Context): Promise<void> {
    db.put(STORE_NAME, CONTEXT_KEY, JSON.stringify(ctx));
  }

  async function readFileFromDb(fileName: string): Promise<string> {
    return db.get(STORE_NAME, fileName);
  }

  interface FileEntry {
    name: string;
    content: string;
  }

  const loadFilesRecursively = async (
    directoryHandle: FileSystemDirectoryHandle,
    path = '',
  ): Promise<FileEntry[]> => {
    let entries: FileEntry[] = [];
    // @ts-ignore
    for await (const entry of directoryHandle.values()) {
      const fullPath = path ? `${path}/${entry.name}` : entry.name;
      if (entry.kind === 'file' && fullPath.endsWith('.mdx')) {
        const file = await entry.getFile();
        const content = await file.text();
        entries.push({ name: fullPath, content });
      } else if (entry.kind === 'directory') {
        const subDirectoryHandle = await directoryHandle.getDirectoryHandle(entry.name, {
          create: false,
        });
        const subEntries = await loadFilesRecursively(subDirectoryHandle, fullPath);
        entries = entries.concat(subEntries);
      }
    }
    return entries;
  };
  const loadConfigFile = async (
    handle: FileSystemDirectoryHandle,
    filenames: string[],
  ): Promise<{
    type: 'json' | 'yaml';
    content: string;
  }> => {
    let content = '';
    let type: 'json' | 'yaml' = 'json';
    for (const filename of filenames) {
      try {
        const fileHandle = await handle.getFileHandle(filename, { create: false });
        const fileData = await fileHandle.getFile();
        content = await fileData.text();
        type = filename.endsWith('.json') ? 'json' : 'yaml';
      } catch (error) {
        // File not found, continue trying other filenames
      }
    }
    return {
      type,
      content,
    };
  };
  const loadDirectoryContents = async (
    directoryHandle: FileSystemDirectoryHandle,
  ): Promise<
    | {
        config: {
          type: 'json' | 'yaml';
          content: string;
        };
        files: FileEntry[];
      }
    | undefined
    | Promise<undefined>
  > => {
    try {
      const { type, content } = await loadConfigFile(directoryHandle, ['docs.json', 'docs.yaml']);
      // Load files from '/docs' directory
      const docsDirectoryHandle = await directoryHandle.getDirectoryHandle('docs', {
        create: false,
      });
      const files = await loadFilesRecursively(docsDirectoryHandle);
      return {
        config: {
          type: type,
          content: content,
        },
        files,
      };
    } catch (error) {
      console.error('Error loading /docs directory:', error);
    }
  };

  const getCookie = (key: string) => {
    const b = document.cookie.match('(^|;)\\s*' + key + '\\s*=\\s*([^;]+)');
    return b ? b.pop() : '';
  };

  const fetchIndex = async (
    config: { type: 'json' | 'yaml'; content: string },
    markdown: string,
  ): Promise<Context | undefined> => {
    const response: GetPreviewResponse = await getPreview({
      markdown: markdown,
      config: {
        [config.type]: config.content,
      },
    });
    // Set the theme color
    const theme = getCookie('theme');
    // Assuming response structure, adjust as needed
    if (response.code === 'OK') {
      const { code, config, frontmatter, headings } = response.data;

      // Get any syncronized tabs
      let tabs = {};
      try {
        tabs = JSON.parse(getCookie('tabs') || '') ?? {};
      } catch {}

      let relativePath = '/';
      let locale: string | undefined;

      // Check whether the request is for a valid locale.
      if (config.locales.length) {
        [locale] = relativePath.split('/').filter(Boolean);
        if (!config.locales.includes(locale)) {
          locale = undefined;
        } else {
          relativePath = relativePath.replace(`/${locale}`, '');
        }
      }

      // Figure out the sidebar based on the locale.
      let sidebar = [];
      if (locale && !Array.isArray(config.sidebar)) {
        sidebar = config.sidebar[locale];
      } else if (!Array.isArray(config.sidebar)) {
        sidebar = config.sidebar['default'] || [];
      } else {
        sidebar = config.sidebar;
      }

      const ctx: Context = {
        isPreviewReady: true,
        frontmatter: frontmatter,
        headings: headings,
        code: replaceMoustacheVariables(config.variables ?? {}, code),
        config: config,
        owner: 'preview',
        repository: 'preview',
        ref: 'preview',
        locale,
        relativePath: '',
        githubPath: '',
        githubRefPath: '',
        sidebar,
        domain: '',
        baseBranch: '',
        source: {
          type: 'commit',
          owner: '',
          repository: '',
          ref: '',
        },
        theme: theme ? (theme === 'dark' ? 'dark' : 'light') : undefined,
        tabs,
      };
      return ctx;
    } else {
      throw new Error('Failed to get preview');
    }
  };


  const selectDirectoryButtonEl = document.querySelector('#select-directory');
  const directoryContainerEl = document.querySelector('#directory-container');
  const selectDirectory = async () => {
    try {
      const handle = await (window as any).showDirectoryPicker();
      const content = await loadDirectoryContents(handle);
      if (content) {
        const { config, files } = content;

        for (const file of files) {
          await addFileToDb(file);
        }
        const markdownFiles = files.filter(
          file => file.name === 'index.mdx' || file.name === 'index.md',
        );
        const indexMarkdownFile = markdownFiles[0];
        if (!indexMarkdownFile) {
          console.error('No index.mdx or index.md file found in /docs directory');
          return;
        }
        const ctx = await fetchIndex(config, indexMarkdownFile.content);
        if (ctx) {
          saveContextInIDB(ctx);
        }
        directoryContainerEl?.remove();
      }
      // if (handle) {
      //   // Request permission to access this directory in the future
      //   const permission = await handle.requestPermission({ mode: 'readwrite' });
      //   if (permission === 'granted') {
      //     // await saveFileHandle(handle);
      //   }
      // }
    } catch (error) {
      console.error('Error selecting directory:', error);
    }
  };
  selectDirectoryButtonEl?.addEventListener('click', selectDirectory);
</script>

    <Root>
      <div id="directory-container" class="flex h-screen flex-col items-center justify-center">
        <button
          id="select-directory"
          class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
        >
          Select Directory
        </button>
      </div>
      <div id="dynamicContent">Loading...</div>
    </Root>
